<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA=Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="author" conent="Jorge Kalmbach">
    <meta name="description" content="Ready for Review - Time Complexity">
    <title>Time Complexity - Ready for Review</title>

    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-46704501-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-46704501-1');
    </script>

    <link rel="stylesheet" type="text/css" href="../css/tachyons.min.css">
  </head>
  <body class="inconsolata pa0">
    <div class="center mt5 w-80 mw7">
      <header class="overflow-hidden">
        <div class="w-100 tl-l tc-ns">
          <ul class="list ma0 mt2 ml1 pa0">
            <li class="di">
              <a class="link gray" href="https://kalmbach.github.io/ready-for-review">
                Home
              </a>
            </li>
            <span class="gray">|</span>
            <li class="di">
              <a class="link gray" href="https://github.com/kalmbach?tab=repositories">
                Repositories
              </a>
            </li>
          </ul>
        </div>
      </header>

      <div class="center tc ma5">
        <h1 class="ma1 light-red" style="font-size:4rem;">Time Complexity</h1>
        <div class="f4 gray">by Jorge Kalmbach</div>
      </div>

      <h3>How fast is your algorithm?</h3>
      <p class="f4 gray lh-copy tj ma2 pb4">
When we want to express how fast an algorithm works, simply measuring the time it takes to run would
not be an accurate representation, that's because the result is subject to external factors: the
execution time may change from one hardware to another and would also be affected by the size of the
input data. Meaning that it would run faster on a different computer or take more time to process 
5000 items than just 5.
      </p>

      <p class="f4 gray lh-copy tj ma2 pb4">
We need a generalized way of expressing how fast an algorithm is able to run regardless of the size
of the input or other external factors. And that is what Time Complexity is, it describes the
computational complexity that requires to run an algorithm, is estimated by counting the number of
elemental operations made by the algorithm, assuming that each elemental operation requires a fixed
amount of time.
      </p>

      <h3>Big O notation</h3>
      <p class="f4 gray lh-copy tj ma2">
For example if we need to find the number 5 in an array of 10 elements:
      </p>
      <p class="f4 light-red b tc ma1 pt1 pb2">
[ 1, 9, 2, 8, 3, 7, 4, 6, 5, 0 ]
      </p>
      <p class="f4 gray lh-copy tj ma2 pb4">
we would need to read every position of the array (that's the elemental operation) until we find the 
number 5, in the worst case we would need to traverse the whole array, meaning that for an array of 
n items, we will need to perform n elemental operations to find the number we are looking for.
      </p>

      <p class="f4 gray lh-copy tj ma2 pb4">
The <span class="f4 light-red b">Big O</span> notation is used to classify algorithms by how they
behave as the input size increases, in terms of how many operations they need for every element of
input. In the example above, for an input with <span class="f4 light-red b">n</span> elements, the
algorithm will need in the worst case to perform <span class="f4 light-red b">n</span> operations
to complete, we say then that it has a time complexity of <span class="f4 light-red b">O(n)</span>.
      </p>
      <p class="f4 gray lh-copy tj ma2 pb4">
<span class="f4 light-red b">O(n)</span> is a <span class="f4 light-red b">linear</span> time 
complexity, because the number of operations is directly proportional to the number of elements in
the input. There are diferent time complexities, the most common are:
<span class="f4 light-red b">constant</span> <span class="f4 light-red b">O(1)</span>,
<span class="f4 light-red b">linear</span> <span class="f4 light-red b">O(n)</span>, 
<span class="f4 light-red b">logarithmic</span> <span class="f4 light-red b">O(log n)</span> and
<span class="f4 light-red b">quadratic</span> <span class="f4 light-red b">O(n2)</span>. 
      </p>

      <p class="f4 gray lh-copy tj ma2 pb4">
In our number finding example, if our algorithm has psychic powers and can predict where the number
is, it will need only a single read operation to retrieve the location of the number in the array, 
no matter how many elements the input has, it will always require just one operation. That is
constant time complexity or <span class="f4 light-red b">O(1)</span>.
      </p>

      <p class="f4 gray lh-copy tj ma2 pb4">
So far we have <span class="f4 light-red b">O(1)</span> constant time complexity when we have a single
operation, <span class="f4 light-red b">O(n)</span> linear time complexity when we have to loop the
input once, <span class="f4 light-red b">O(n2)</span> quadratic time complexity when we have a loop 
in a loop, and <span class="f4 light-red b">O(log n)</span> logarithmic time complexity, a common 
example of this is a binary search, when the total amount of operations is less than a normal loop.
      </p>

      <h3>Which is the best one?</h3>
      <p class="f4 gray lh-copy tj ma2 pb2">
We can see in the following list, how the time complexity goes from best to nevermind.
      <p>
      <ul>
        <li><span class="f4 light-red b">O(1)</span> best</li>
        <li><span class="f4 light-red b">O(log n)</span> good</li>
        <li><span class="f4 light-red b">O(n)</span> fair</li>
        <li><span class="f4 light-red b">O(n log n)</span> not as bad as quadratic</li>
        <li><span class="f4 light-red b">O(n2)</span> bad</li>
        <li><span class="f4 light-red b">O(n3)</span> worst</li>
        <li><span class="f4 light-red b">O(2n)</span> give up</li>
      </ul>
      <p class="f4 gray lh-copy tj ma2 pb2">
When comparing algorithms using the <span class="f4 light-red b">Big O</span> notation, is 
guaranteed that the more efficient one will be faster eventually as the input size is increased.
      </p>
      <p class="f4 gray lh-copy tj ma2 pb2">
Now we know what time complexity is and how it can help to determine the efficiency of an algorithm.
I hope this was helpful and I'll see you in the next one.
      </p>
    </div>
  </body>
</html>
